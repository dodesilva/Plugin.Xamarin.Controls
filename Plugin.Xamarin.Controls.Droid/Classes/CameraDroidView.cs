using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Android.App;
using Android.Content;
using Android.Content.PM;
using Android.Graphics;
using Android.Hardware.Camera2;
using Android.Hardware.Camera2.Params;
using Android.Media;
using Android.OS;
using Android.Runtime;
using Android.Util;
using Android.Views;
using Android.Widget;
using Java.IO;
using Java.Lang;
using Java.Util;
using Java.Util.Concurrent;
using Plugin.Xamarin.Controls.Droid.Classes;
using Plugin.Xamarin.Controls.Droid.Listner;
using Plugin.Xamarin.Controls.EnumFiles;
using Plugin.Xamarin.Controls.Helpers;
using Xamform = Xamarin.Forms;
using Boolean = Java.Lang.Boolean;
using Math = Java.Lang.Math;
using Android;
using Android.Support.V4.Content;
using Android.Support.V4.App;

namespace Plugin.Xamarin.Controls.Droid.Classes
{
    public class CameraDroidView : FrameLayout
    {
        #region property
        private readonly Context _context;
        Android.Widget.RelativeLayout mainLayout;
        public event EventHandler<MediaFiles> OnFinichedCapture;
        /** Current zoom value. 1.0 is no zoom. */
        public float mZoomValue = 1f;
        /** Current crop region: set from mZoomValue. */
        public Rect mCropRegion;
        public float maximumZoomLevel;
        private bool isPaused = false;
        public SurfaceTexture _surface { get; set; }
        public string VideoFuulPath { get; set; }
        PaintCodeButton capturePhotoButton;
        PaintCodeButtonStop StopButton;
        ImageButton PausePlayButton;
        ImageButton flashButton;
        ImageButton switchButton;
        ImageButton recordButton;
        MediaPlayer player;
        public Activity Activityresult => this.Context as Activity;
        public static readonly SparseIntArray ORIENTATIONS = new SparseIntArray();
        private int FLASH_STATE_OFF = 0;
        private int FLASH_STATE_ON = 1;
        private int FLASH_STATE_AUTO = 2;
        private int mFlashState = 0;
        public bool mAutoFocusSupported;
        public const int STATE_PREVIEW = 0;
        // Camera state: Waiting for the focus to be locked.
        public const int STATE_WAITING_LOCK = 1;
        // Camera state: Waiting for the exposure to be precapture state.
        public const int STATE_WAITING_PRECAPTURE = 2;
        //Camera state: Waiting for the exposure state to be something other than precapture.
        public const int STATE_WAITING_NON_PRECAPTURE = 3;
        // Camera state: Picture was taken.
        public const int STATE_PICTURE_TAKEN = 4;
        // Max preview width that is guaranteed by Camera2 API
        public static readonly int MAX_PREVIEW_WIDTH = 1920;
        // Max preview height that is guaranteed by Camera2 API
        public static readonly int MAX_PREVIEW_HEIGHT = 1280;
        // ID of the current {@link CameraDevice}.
        public CameraOptions mCameraId { get; set; }
        public int textwidth { get; set; }
        public int textheight { get; set; }
        // An AutoFitTextureView for camera preview
        public CameraTextureView mTextureView;
        // A {@link CameraCaptureSession } for camera preview.
        public CameraCaptureSession mCaptureSession;
        // A reference to the opened CameraDevice
        public CameraDevice mCameraDevice;
        public MediaRecorder mediaRecorder;
        private bool isRecordingVideo;
        // The size of the camera preview
        private Size mPreviewSize;
        private Size previewSize;
        private Size videoSize;
        // CameraDevice.StateListener is called when a CameraDevice changes its state
        private CameraStateListener mStateCallback;
        // An additional thread for running tasks that shouldn't block the UI.
        private HandlerThread mBackgroundThread;
        // A {@link Handler} for running tasks in the background.
        public Handler mBackgroundHandler;
        // An {@link ImageReader} that handles still image capture.
        private ImageReader mImageReader;
        private ImageAvailableListener mOnImageAvailableListener;
        // This is the output file for our picture.
        public File mFile;
        private CameraSurfaceTextureListener mSurfaceTextureListener;
        //{@link CaptureRequest.Builder} for the camera preview
        public CaptureRequest.Builder mPreviewRequestBuilder;
        // {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
        public CaptureRequest mPreviewRequest;
        // The current state of camera state for taking pictures.
        public int mState = STATE_PREVIEW;
        // A {@link Semaphore} to prevent the app from exiting before closing the camera.
        public Semaphore mCameraOpenCloseLock = new Semaphore(1);
        // Whether the current camera device supports Flash or not.
        private bool mFlashSupported;
        // Orientation of the camera sensor
        private int mSensorOrientation;
        // A {@link CameraCaptureSession.CaptureCallback} that handles events related to JPEG capture.
        public CameraCaptureListener mCaptureCallback;
        public CameraCharacteristics characteristics;
        public float fingerSpacing = 0;
        #endregion
        public Rect cropRegionForZoom(CameraCharacteristics characteristics, float zoom)
        {
            Rect sensor = (Rect)characteristics.Get(CameraCharacteristics.SensorInfoActiveArraySize);
            int xCenter = sensor.Width() / 2;
            int yCenter = sensor.Height() / 2;
            int xDelta = (int)(0.5f * sensor.Width() / zoom);
            int yDelta = (int)(0.5f * sensor.Height() / zoom);
            return new Rect(xCenter - xDelta, yCenter - yDelta, xCenter + xDelta, yCenter + yDelta);
        }
        public Rect cropRegionForZoom(float zoom)
        {
            return cropRegionForZoom(characteristics, zoom);
        }
        private float GetMaxZoom()
        {
            return (float)characteristics.Get(CameraCharacteristics.ScalerAvailableMaxDigitalZoom);
        }
        public void SetZoom(float zoom)
        {
            mZoomValue = zoom;
            mCropRegion = cropRegionForZoom(zoom);
        }
        public CameraDroidView(Context context, CameraOptions options) : base(context)
        {
            _context = context;
            mStateCallback = new CameraStateListener(this);
            mSurfaceTextureListener = new CameraSurfaceTextureListener(this);
            mCaptureCallback = new CameraCaptureListener(this);
            mCameraId = options;
            mOnImageAvailableListener = new ImageAvailableListener();
            mOnImageAvailableListener.Photo += MOnImageAvailableListener_Photo;
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation0, 90);
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation90, 0);
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation180, 270);
            ORIENTATIONS.Append((int)SurfaceOrientation.Rotation270, 180);
            SetupUserInterface();
            SetupEventHandlers();
            ChangeButton(false);
            player = MediaPlayer.Create(Context, Resource.Raw.CameraBeep);
        }
        private async void MOnImageAvailableListener_Photo(object sender, byte[] buffer)
        {

            VideoFuulPath = AndroidImageHelper.SaveFile(buffer, "Ds Call");

            var imgsource = await AndroidImageHelper.RotateImage(buffer);
            var media = new MediaFiles
            {
                FullPath = VideoFuulPath,
                FileSource = imgsource,
                ContentByte = buffer,
                MimeType = "image/jpeg",
                Success = true
            };
            OnFinichedCapture?.Invoke(this, media);
        }
        private void SetupEventHandlers()
        {
            capturePhotoButton.Click += (sender, e) =>
            {
                player.Start();
                stillCaptureBuilder = null;
                CaptureStillPicture();
                //LockFocus();
                player.Stop();

            };
            recordButton.Click += (sender, e) =>
            {

                if (!isRecordingVideo)
                {
                    startPreview();
                    StartRecordingVideo();
                }
                ChangeButton(true);
            };
            StopButton.Click += async (sender, e) =>
            {
                if (isRecordingVideo)
                {
                    stopRecordingVideo();
                }

            };
            PausePlayButton.Click += (sender, e) =>
            {
                PlayPauseVideo();
            };
            flashButton.Click += (s, e) =>
            {
                if (mFlashState == FLASH_STATE_OFF)
                {
                    mFlashState = FLASH_STATE_ON;
                    flashButton.SetImageResource(Resource.Drawable.ic_flash);
                }
                else if (mFlashState == FLASH_STATE_ON)
                {
                    mFlashState = FLASH_STATE_AUTO;
                    flashButton.SetImageResource(Resource.Drawable.ic_flash_auto);
                }
                else if (mFlashState == FLASH_STATE_AUTO)
                {
                    mFlashState = FLASH_STATE_OFF;
                    flashButton.SetImageResource(Resource.Drawable.ic_flash_off);
                }
                SetAutoFlash(mPreviewRequestBuilder);
            };
            switchButton.Click += (s, e) =>
            {
                SwitchCamera();
            };

            mTextureView.SurfaceTextureListener = mSurfaceTextureListener;
        }
        private void PlayPauseVideo()
        {
            if (isPaused)
            {
                mediaRecorder.Resume();
                PausePlayButton.SetImageResource(Resource.Drawable.ic_pause_circle_outline);
                isPaused = false;
            }
            else
            {
                PausePlayButton.SetImageResource(Resource.Drawable.ic_play_circle_outline);
                mediaRecorder.Pause();
                isPaused = true;
            }
        }
        private void ChangeButton(bool state)
        {
            if (state)
            {

                switchButton.Visibility = ViewStates.Invisible;
                flashButton.Visibility = ViewStates.Invisible;
                recordButton.Visibility = ViewStates.Invisible;
                capturePhotoButton.Visibility = ViewStates.Invisible;
                StopButton.Visibility = ViewStates.Visible;
                PausePlayButton.Visibility = ViewStates.Visible;
            }
            else
            {
                StopButton.Visibility = ViewStates.Invisible;
                PausePlayButton.Visibility = ViewStates.Invisible;
                switchButton.Visibility = ViewStates.Visible;
                flashButton.Visibility = ViewStates.Visible;
                recordButton.Visibility = ViewStates.Visible;
                capturePhotoButton.Visibility = ViewStates.Visible;
            }
        }
        public void SwitchCamera()
        {
            try
            {
                if (mCameraId == CameraOptions.Rear)
                {
                    mFlashState = FLASH_STATE_OFF;
                    flashButton.SetImageResource(Resource.Drawable.ic_flash_off);
                    flashButton.Visibility = ViewStates.Invisible;
                    mCameraId = CameraOptions.Front;
                }
                else if (mCameraId == CameraOptions.Front)
                {
                    flashButton.Visibility = ViewStates.Visible;
                    mCameraId = CameraOptions.Rear;
                }
                CloseCamera();
                OpenCamera(mTextureView.Width, mTextureView.Height);
            }
            catch (Java.IO.IOException exception)
            {
            }
        }
        void SetupUserInterface()
        {
            mainLayout = new RelativeLayout(Context);
            RelativeLayout.LayoutParams mainLayoutParams = new RelativeLayout.LayoutParams(LayoutParams.MatchParent, LayoutParams.MatchParent);
            mainLayout.LayoutParameters = mainLayoutParams;

            mTextureView = new CameraTextureView(Context);

            RelativeLayout.LayoutParams liveViewParams = new RelativeLayout.LayoutParams(
                RelativeLayout.LayoutParams.MatchParent,
                RelativeLayout.LayoutParams.MatchParent);
            mTextureView.LayoutParameters = liveViewParams;



            StopButton = new PaintCodeButtonStop(Context);
            RelativeLayout.LayoutParams StopButtonParams = new RelativeLayout.LayoutParams(LayoutParams.WrapContent, LayoutParams.WrapContent);
            StopButtonParams.Height = 150;
            StopButtonParams.Width = 150;
            StopButton.LayoutParameters = StopButtonParams;

            PausePlayButton = new ImageButton(Context);
            PausePlayButton.SetBackgroundColor(Color.Transparent);
            PausePlayButton.SetImageResource(Resource.Drawable.ic_pause_circle_outline);
            RelativeLayout.LayoutParams PausePlayButtonParams = new RelativeLayout.LayoutParams(LayoutParams.WrapContent, LayoutParams.WrapContent);
            PausePlayButtonParams.Height = 150;
            PausePlayButtonParams.Width = 150;
            PausePlayButton.LayoutParameters = PausePlayButtonParams;

            flashButton = new ImageButton(Context);
            flashButton.SetBackgroundColor(Color.Transparent);
            flashButton.SetImageResource(Resource.Drawable.ic_flash_off);

            RelativeLayout.LayoutParams flashButtonParams = new RelativeLayout.LayoutParams(LayoutParams.WrapContent, LayoutParams.WrapContent);
            flashButtonParams.Height = 150;
            flashButtonParams.Width = 150;
            flashButton.LayoutParameters = flashButtonParams;

            recordButton = new ImageButton(Context);
            recordButton.SetBackgroundColor(Color.Transparent);
            recordButton.SetImageResource(Resource.Drawable.ic_record);
            RelativeLayout.LayoutParams recordButtonParams = new RelativeLayout.LayoutParams(LayoutParams.WrapContent, LayoutParams.WrapContent);
            recordButtonParams.Height = 150;
            recordButtonParams.Width = 150;
            recordButton.LayoutParameters = recordButtonParams;

            capturePhotoButton = new PaintCodeButton(Context);
            RelativeLayout.LayoutParams captureButtonParams = new RelativeLayout.LayoutParams(LayoutParams.WrapContent, LayoutParams.WrapContent);
            captureButtonParams.Height = 150;
            captureButtonParams.Width = 150;
            capturePhotoButton.LayoutParameters = captureButtonParams;

            switchButton = new ImageButton(Context);
            switchButton.SetBackgroundColor(Color.Transparent);
            switchButton.SetImageResource(Resource.Drawable.ic_switch_cam);
            RelativeLayout.LayoutParams switchButtonParams = new RelativeLayout.LayoutParams(LayoutParams.WrapContent, LayoutParams.WrapContent);
            switchButtonParams.Height = 150;
            switchButtonParams.Width = 150;
            switchButton.LayoutParameters = switchButtonParams;

            mainLayout.AddView(mTextureView);
            mainLayout.AddView(flashButton);

            mainLayout.AddView(StopButton);
            mainLayout.AddView(PausePlayButton);
            mainLayout.AddView(recordButton);

            mainLayout.AddView(capturePhotoButton);
            mainLayout.AddView(switchButton);
            AddView(mainLayout);
        }
        public void ConfigureTransform(int viewWidth, int viewHeight)
        {
            if (null == mTextureView || null == mPreviewSize || null == _context)
            {
                return;
            }
            var windowManager = _context.GetSystemService(Context.WindowService).JavaCast<IWindowManager>();
            var rotation = (int)windowManager.DefaultDisplay.Rotation;
            Matrix matrix = new Matrix();
            RectF viewRect = new RectF(0, 0, viewWidth, viewHeight);
            RectF bufferRect = new RectF(0, 0, mPreviewSize.Height, mPreviewSize.Width);
            float centerX = viewRect.CenterX();
            float centerY = viewRect.CenterY();
            if ((int)SurfaceOrientation.Rotation90 == rotation || (int)SurfaceOrientation.Rotation270 == rotation)
            {
                bufferRect.Offset(centerX - bufferRect.CenterX(), centerY - bufferRect.CenterY());
                matrix.SetRectToRect(viewRect, bufferRect, Matrix.ScaleToFit.Fill);
                float scale = Math.Max((float)viewHeight, (float)viewWidth);
                matrix.PostScale(scale, scale, centerX, centerY);
                matrix.PostRotate(90 * (rotation - 2), centerX, centerY);
            }
            else if ((int)SurfaceOrientation.Rotation180 == rotation)
            {
                matrix.PostRotate(180, centerX, centerY);
            }
            mTextureView.SetTransform(matrix);
        }

        private bool CameraPermissions()
        {
            string[] CameraPermissions =
            {
                Manifest.Permission.Camera,
                Manifest.Permission.RecordAudio,
                Manifest.Permission.WriteExternalStorage,
                Manifest.Permission.ReadExternalStorage
            };
            foreach (string pm in CameraPermissions)
            {
                if ((int)Build.VERSION.SdkInt < 23 || ContextCompat.CheckSelfPermission(Android.App.Application.Context, pm) == Permission.Granted)
                {
                    return true;
                }
            }

            ActivityCompat.RequestPermissions(Activityresult, CameraPermissions, 1000);

            return false;
        }
        public void OpenCamera(int width, int height)
        {
            if (!CameraPermissions())
            {
                return;
            }
            else
            {
                SetUpCameraOutputs(width, height);
                ConfigureTransform(width, height);
                var manager = (CameraManager)_context.GetSystemService(Context.CameraService);
                try
                {
                    if (!mCameraOpenCloseLock.TryAcquire(2500, TimeUnit.Milliseconds))
                    {
                        throw new RuntimeException("Time out waiting to lock camera opening.");
                    }

                    mediaRecorder = new MediaRecorder();
                    var cameraId = manager.GetCameraIdList()[(int)mCameraId];
                    manager.OpenCamera(cameraId, mStateCallback, mBackgroundHandler);
                }
                catch (CameraAccessException e)
                {
                    e.PrintStackTrace();
                }
                catch (InterruptedException e)
                {
                    throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
                }

            }
        }
        private void CloseCamera()
        {
            try
            {
                mCameraOpenCloseLock.Acquire();
                if (null != mCaptureSession)
                {
                    mCaptureSession.Close();
                    mCaptureSession = null;
                }
                if (null != mCameraDevice)
                {
                    mCameraDevice.Close();
                    mCameraDevice = null;
                }
                if (null != mediaRecorder)
                {
                    mediaRecorder.Release();
                    mediaRecorder = null;
                }
                if (null != mImageReader)
                {
                    mImageReader.Close();
                    mImageReader = null;
                }
                //StopBackgroundThread();
            }
            catch (InterruptedException e)
            {
                throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
            }
            finally
            {
                mCameraOpenCloseLock.Release();
            }
        }
        public void SetUpCameraOutputs(int width, int height)
        {
            var manager = (CameraManager)_context.GetSystemService(Context.CameraService);
            try
            {
                var cameraId = manager.GetCameraIdList()[(int)mCameraId];
                characteristics = manager.GetCameraCharacteristics(cameraId);
                maximumZoomLevel = (float)characteristics.Get(CameraCharacteristics.ScalerAvailableMaxDigitalZoom);
                var map = (StreamConfigurationMap)characteristics.Get(CameraCharacteristics.ScalerStreamConfigurationMap);

                Size largest = (Size)Collections.Max(Arrays.AsList(map.GetOutputSizes((int)ImageFormatType.Jpeg)), new CompareSizesByArea());
                mImageReader = ImageReader.NewInstance(largest.Width, largest.Height, ImageFormatType.Jpeg, 1);
                mImageReader.SetOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);
                videoSize = ChooseVideoSize(map.GetOutputSizes(Class.FromType(typeof(MediaRecorder))));
                previewSize = ChooseOptimalSize(map.GetOutputSizes(Class.FromType(typeof(MediaRecorder))), textwidth, textheight, videoSize);

                var displayRotation = Activityresult.WindowManager.DefaultDisplay.Rotation;

                //noinspection ConstantConditions
                mSensorOrientation = (int)characteristics.Get(CameraCharacteristics.SensorOrientation);
                bool swappedDimensions = false;
                switch (displayRotation)
                {
                    case SurfaceOrientation.Rotation0:
                    case SurfaceOrientation.Rotation180:
                        if (mSensorOrientation == 90 || mSensorOrientation == 270)
                        {
                            swappedDimensions = true;
                        }
                        break;
                    case SurfaceOrientation.Rotation90:
                    case SurfaceOrientation.Rotation270:
                        if (mSensorOrientation == 0 || mSensorOrientation == 180)
                        {
                            swappedDimensions = true;
                        }
                        break;
                    default:
                        break;
                }

                Point displaySize = new Point();
                Activityresult.WindowManager.DefaultDisplay.GetSize(displaySize);
                var rotatedPreviewWidth = width;
                var rotatedPreviewHeight = height;
                var maxPreviewWidth = displaySize.X;
                var maxPreviewHeight = displaySize.Y;

                if (swappedDimensions)
                {
                    rotatedPreviewWidth = height;
                    rotatedPreviewHeight = width;
                    maxPreviewWidth = displaySize.Y;
                    maxPreviewHeight = displaySize.X;
                }

                if (maxPreviewWidth > MAX_PREVIEW_WIDTH)
                {
                    maxPreviewWidth = MAX_PREVIEW_WIDTH;
                }

                if (maxPreviewHeight > MAX_PREVIEW_HEIGHT)
                {
                    maxPreviewHeight = MAX_PREVIEW_HEIGHT;
                }

                // Danger, W.R.! Attempting to use too large a preview size could  exceed the camera
                // bus' bandwidth limitation, resulting in gorgeous previews but the storage of
                // garbage capture data.
                mPreviewSize = ChooseOptimalSize(map.GetOutputSizes(Class.FromType(typeof(SurfaceTexture))),
                    rotatedPreviewWidth, rotatedPreviewHeight, maxPreviewWidth,
                    maxPreviewHeight, largest);

                // We fit the aspect ratio of TextureView to the size of preview we picked.
                var orientation = Resources.Configuration.Orientation;
                if (orientation == Android.Content.Res.Orientation.Landscape)
                {
                    mTextureView.SetAspectRatio(mPreviewSize.Width, mPreviewSize.Height);
                }
                else
                {
                    mTextureView.SetAspectRatio(mPreviewSize.Height, mPreviewSize.Width);
                }

                // Check if the flash is supported.
                var available = (Boolean)characteristics.Get(CameraCharacteristics.FlashInfoAvailable);
                mFlashSupported = available == null ? false : (bool)available;
                int[] afAvailableModes = (int[])characteristics.Get(CameraCharacteristics.ControlAfAvailableModes);
                if (afAvailableModes.Length == 0 || (afAvailableModes.Length == 1) && afAvailableModes[0] == CameraMetadata.DistortionCorrectionModeOff)
                {
                    mAutoFocusSupported = false;
                }
                else
                {
                    mAutoFocusSupported = true;
                }
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (NullPointerException e)
            {
                ShowToast("Cannot access the camera.");
            }
        }
        private Size ChooseOptimalSize(Size[] choices, int width, int height, Size aspectRatio)
        {
            var bigEnough = new List<Size>();
            int w = aspectRatio.Width;
            int h = aspectRatio.Height;
            foreach (Size option in choices)
            {
                if (option.Height == option.Width * h / w &&
                    option.Width >= width && option.Height >= height)
                    bigEnough.Add(option);
            }

            if (bigEnough.Count > 0)
                return (Size)Collections.Min(bigEnough, new CompareSizesByArea());
            else
            {
                return choices[0];
            }
        }
        private Size ChooseVideoSize(Size[] choices)
        {
            foreach (Size size in choices)
            {
                if (size.Width == size.Height * 4 / 3 && size.Width <= 1000)
                    return size;
            }
            return choices[choices.Length - 1];
        }
        public void CreateCameraPreviewSession()
        {
            try
            {
                _surface = mTextureView.SurfaceTexture;
                if (_surface == null)
                {
                    throw new IllegalStateException("texture is null");
                }

                _surface.SetDefaultBufferSize(mPreviewSize.Width, mPreviewSize.Height);

                // This is the output Surface we need to start preview.
                Surface surface = new Surface(_surface);

                // We set up a CaptureRequest.Builder with the output Surface.
                mPreviewRequestBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.Preview);
                mPreviewRequestBuilder.AddTarget(surface);

                // Here, we create a CameraCaptureSession for camera preview.
                List<Surface> surfaces = new List<Surface>();
                surfaces.Add(surface);
                surfaces.Add(mImageReader.Surface);
                mCameraDevice.CreateCaptureSession(surfaces, new CameraCaptureSessionCallback(this), null);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }
        public void startPreview()
        {
            if (null == mCameraDevice || !mTextureView.IsAvailable || null == previewSize)
                return;

            try
            {
                SetUpMediaRecorder(_context);
                _surface = mTextureView.SurfaceTexture;
                //Assert.IsNotNull(texture);
                _surface.SetDefaultBufferSize(previewSize.Width, previewSize.Height);
                mPreviewRequestBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.Record);
                var surfaces = new List<Surface>();
                var previewSurface = new Surface(_surface);
                surfaces.Add(previewSurface);
                mPreviewRequestBuilder.AddTarget(previewSurface);

                var recorderSurface = mediaRecorder.Surface;
                surfaces.Add(recorderSurface);
                mPreviewRequestBuilder.AddTarget(recorderSurface);

                mCameraDevice.CreateCaptureSession(surfaces, new CameraCaptureSessionCallback(this), mBackgroundHandler);

            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
            catch (IOException e)
            {
                e.PrintStackTrace();
            }
        }
        // Lock the focus as the first step for a still image capture.
        private void LockFocus()
        {
            try
            {
                // This is how to tell the camera to lock focus.
                mPreviewRequestBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Start);
                // Tell #mCaptureCallback to wait for the lock.
                mState = STATE_WAITING_LOCK;
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback, mBackgroundHandler);

            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }
        private void SetUpMediaRecorder(Context context)
        {
            if (_context == null)
                return;

            var guid = Guid.NewGuid();
            string fileName = "Video-" + guid + ".mp4";
            mFile = new File(Android.OS.Environment.ExternalStorageDirectory + "/Ds Call", "Video");
            if (!mFile.Exists())
            {
                mFile.Mkdir();
            }
            VideoFuulPath = System.IO.Path.Combine(mFile.AbsolutePath, fileName);

            mediaRecorder.SetAudioSource(AudioSource.Mic);
            mediaRecorder.SetVideoSource(VideoSource.Surface);
            mediaRecorder.SetOutputFormat(OutputFormat.Mpeg4);
            mediaRecorder.SetOutputFile(VideoFuulPath);
            mediaRecorder.SetVideoEncodingBitRate(10000000);
            mediaRecorder.SetVideoFrameRate(30);
            mediaRecorder.SetVideoSize(videoSize.Width, videoSize.Height);
            mediaRecorder.SetVideoEncoder(VideoEncoder.H264);
            mediaRecorder.SetAudioEncoder(AudioEncoder.Aac);
            int rotation = (int)Activityresult.WindowManager.DefaultDisplay.Rotation;
            int orientation = ORIENTATIONS.Get(rotation);
            mediaRecorder.SetOrientationHint(orientation);
            mediaRecorder.Prepare();
        }
        public void ShowToast(string text)
        {
            if (_context != null)
            {
                Toast.MakeText(_context, text, ToastLength.Long).Show();
            }
        }
        //Update the preview
        public void updatePreview()
        {
            if (null == mCameraDevice)
                return;

            try
            {
                setUpCaptureRequestBuilder(mPreviewRequestBuilder);
                HandlerThread thread = new HandlerThread("CameraPreview");
                thread.Start();
                mCaptureSession.SetRepeatingRequest(mPreviewRequest, null, mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }
        private void StartRecordingVideo()
        {
            try
            {
                isRecordingVideo = true;

                //Start recording
                mediaRecorder.Start();
            }
            catch (IllegalStateException e)
            {
                e.PrintStackTrace();
            }
        }
        public void stopRecordingVideo()
        {
            //UI
            isRecordingVideo = false;
            mediaRecorder.Stop();
            mediaRecorder.Reset();
            ChangeButton(false);
            if (_context != null)
            {
                byte[] buffer = System.IO.File.ReadAllBytes(VideoFuulPath);
                var media = new MediaFiles
                {
                    FullPath = VideoFuulPath,
                    FileSource = Xamform.ImageSource.FromStream(() => new System.IO.MemoryStream(buffer)),
                    ContentByte = buffer,
                    MimeType = "video/mp4",
                    Success = true
                };
                OnFinichedCapture?.Invoke(this, media);
            }

            CloseCamera();
            OpenCamera(mTextureView.Width, mTextureView.Height);

        }
        private void setUpCaptureRequestBuilder(CaptureRequest.Builder builder)
        {
            builder.Set(CaptureRequest.ControlMode, new Java.Lang.Integer((int)ControlMode.Auto));
        }
        private static Size ChooseOptimalSize(Size[] choices, int textureViewWidth, int textureViewHeight, int maxWidth, int maxHeight, Size aspectRatio)
        {
            // Collect the supported resolutions that are at least as big as the preview Surface
            var bigEnough = new List<Size>();
            // Collect the supported resolutions that are smaller than the preview Surface
            var notBigEnough = new List<Size>();
            int w = aspectRatio.Width;
            int h = aspectRatio.Height;

            for (var i = 0; i < choices.Length; i++)
            {
                Size option = choices[i];
                if ((option.Width <= maxWidth) && (option.Height <= maxHeight) &&
                       option.Height == option.Width * h / w)
                {
                    if (option.Width >= textureViewWidth &&
                        option.Height >= textureViewHeight)
                    {
                        bigEnough.Add(option);
                    }
                    else
                    {
                        notBigEnough.Add(option);
                    }
                }
            }

            // Pick the smallest of those big enough. If there is no one big enough, pick the
            // largest of those not big enough.
            if (bigEnough.Count > 0)
            {
                return (Size)Collections.Min(bigEnough, new CompareSizesByArea());
            }
            else if (notBigEnough.Count > 0)
            {
                return (Size)Collections.Max(notBigEnough, new CompareSizesByArea());
            }
            else
            {
                return choices[0];
            }
        }
        private CaptureRequest.Builder stillCaptureBuilder;
        // Capture a still picture. This method should be called when we get a response in
        // {@link #mCaptureCallback} from both {@link #lockFocus()}.
        public void CaptureStillPicture()
        {
            try
            {
                if (_context == null || null == mCameraDevice)
                {
                    return;
                }
                // This is the CaptureRequest.Builder that we use to take a picture.
                if (stillCaptureBuilder == null)
                    stillCaptureBuilder = mCameraDevice.CreateCaptureRequest(CameraTemplate.StillCapture);

                stillCaptureBuilder.AddTarget(mImageReader.Surface);
                stillCaptureBuilder.Set(CaptureRequest.ScalerCropRegion, mCropRegion);
                // Use the same AE and AF modes as the preview.
                stillCaptureBuilder.Set(CaptureRequest.ControlAfMode, (int)ControlAFMode.ContinuousPicture);
                SetAutoFlash(stillCaptureBuilder);

                // Orientation
                int rotation = (int)Activityresult.WindowManager.DefaultDisplay.Rotation;
                stillCaptureBuilder.Set(CaptureRequest.JpegOrientation, GetOrientation(rotation));

                mCaptureSession.StopRepeating();
                mCaptureSession.Capture(stillCaptureBuilder.Build(), new CameraCaptureStillPictureSessionCallback(this), null);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }
        private int GetOrientation(int rotation)
        {
            // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
            // We have to take that into account and rotate JPEG properly.
            // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.
            // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
            return (ORIENTATIONS.Get(rotation) + mSensorOrientation + 270) % 360;
        }
        public void UnlockFocus()
        {
            try
            {
                // Reset the auto-focus trigger
                mPreviewRequestBuilder.Set(CaptureRequest.ControlAfTrigger, (int)ControlAFTrigger.Cancel);
                SetAutoFlash(mPreviewRequestBuilder);
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback, mBackgroundHandler);
                // After this, the camera will go back to the normal state of preview.
                mState = STATE_PREVIEW;
                mCaptureSession.SetRepeatingRequest(mPreviewRequest, mCaptureCallback, mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }
        public void RunPrecaptureSequence()
        {
            try
            {
                // This is how to tell the camera to trigger.
                mPreviewRequestBuilder.Set(CaptureRequest.ControlAePrecaptureTrigger, (int)ControlAEPrecaptureTrigger.Start);
                // Tell #mCaptureCallback to wait for the precapture sequence to be set.
                mState = STATE_WAITING_PRECAPTURE;
                mCaptureSession.Capture(mPreviewRequestBuilder.Build(), mCaptureCallback, mBackgroundHandler);
            }
            catch (CameraAccessException e)
            {
                e.PrintStackTrace();
            }
        }
        public void SetAutoFlash(CaptureRequest.Builder requestBuilder)
        {
            if (mFlashSupported)
            {
                if (mFlashState == FLASH_STATE_OFF)
                {
                    //requestBuilder.Set(CaptureRequest.ControlAeMode, (int)ControlAEMode.On);
                    requestBuilder.Set(CaptureRequest.FlashMode, (int)FlashMode.Off);
                }
                else if (mFlashState == FLASH_STATE_ON)
                {
                    // requestBuilder.Set(CaptureRequest.ControlAeMode, (int)ControlAEMode.OnAlwaysFlash);
                    requestBuilder.Set(CaptureRequest.FlashMode, (int)FlashMode.Single);
                }
                else if (mFlashState == FLASH_STATE_AUTO)
                    requestBuilder.Set(CaptureRequest.ControlAeMode, (int)ControlAEMode.OnAutoFlash);
            }
        }
        protected override void OnLayout(bool changed, int l, int t, int r, int b)
        {
            base.OnLayout(changed, l, t, r, b);
            if (!changed)
                return;

            var msw = MeasureSpec.MakeMeasureSpec(r - l, MeasureSpecMode.Exactly);
            var msh = MeasureSpec.MakeMeasureSpec(b - t, MeasureSpecMode.Exactly);
            mainLayout.Measure(msw, msh);
            mainLayout.Layout(0, 0, r - l, b - t);
            flashButton.SetX(mainLayout.Width - 200);
            flashButton.SetY(50);
            recordButton.SetX(mainLayout.Width / 2 - 340);
            recordButton.SetY(mainLayout.Height - 250);
            capturePhotoButton.SetX(mainLayout.Width / 2 - 60);
            capturePhotoButton.SetY(mainLayout.Height - 250);
            switchButton.SetX(mainLayout.Width / 2 + 220);
            switchButton.SetY(mainLayout.Height - 250);
            StopButton.SetX(mainLayout.Width / 2 - 60);
            StopButton.SetY(mainLayout.Height - 250);
            PausePlayButton.SetX(mainLayout.Width / 2 + 220);
            PausePlayButton.SetY(mainLayout.Height - 250);
        }
        public void StartBackgroundThread()
        {
            Activityresult.RequestedOrientation = ScreenOrientation.Locked;
            mBackgroundThread = new HandlerThread("CameraBackground");
            mBackgroundThread.Start();
            mBackgroundHandler = new Handler(mBackgroundThread.Looper);
        }
        // Stops the background thread and its {@link Handler}.
        public void StopBackgroundThread()
        {
            Activityresult.RequestedOrientation = ScreenOrientation.Unspecified;
            mBackgroundThread.QuitSafely();
            try
            {
                CloseCamera();
                mBackgroundThread.Join();
                mBackgroundThread = null;
                mBackgroundHandler = null;
            }
            catch (InterruptedException e)
            {
                e.PrintStackTrace();
            }
        }
        public override bool OnTouchEvent(MotionEvent e)
        {
            Rect rect = (Rect)characteristics.Get(CameraCharacteristics.SensorInfoActiveArraySize);
            if (rect == null) return false;
            float currentFingerSpacing;

            if (e.PointerCount == 2)
            { //Multi touch.
                currentFingerSpacing = GetFingerSpacing(e);
                float delta = 0.05f;
                if (fingerSpacing != 0)
                {
                    if (currentFingerSpacing > fingerSpacing)
                    {
                        if ((maximumZoomLevel - mZoomValue) <= delta)
                        {
                            delta = maximumZoomLevel - mZoomValue;
                        }
                        mZoomValue = mZoomValue + delta;
                    }
                    else if (currentFingerSpacing < fingerSpacing)
                    {
                        if ((mZoomValue - delta) < 1f)
                        {
                            delta = mZoomValue - 1f;
                        }
                        mZoomValue = mZoomValue - delta;
                    }
                    float ratio = (float)1 / mZoomValue;
                    int croppedWidth = rect.Width() - Math.Round((float)rect.Width() * ratio);
                    int croppedHeight = rect.Height() - Math.Round((float)rect.Height() * ratio);
                    mCropRegion = new Rect(croppedWidth / 2, croppedHeight / 2, rect.Width() - croppedWidth / 2, rect.Height() - croppedHeight / 2);
                    mPreviewRequestBuilder.Set(CaptureRequest.ScalerCropRegion, mCropRegion);
                }
                fingerSpacing = currentFingerSpacing;
            }
            else
            { //Single touch point, needs to return true in order to detect one more touch point
                return true;
            }
            mCaptureSession.SetRepeatingRequest(mPreviewRequestBuilder.Build(), mCaptureCallback, mBackgroundHandler);
            return base.OnTouchEvent(e);
        }

        private float GetFingerSpacing(MotionEvent e)
        {
            float x = e.GetX(0) - e.GetX(1);
            float y = e.GetY(0) - e.GetY(1);
            return (float)Math.Sqrt(x * x + y * y);
        }
    }
}